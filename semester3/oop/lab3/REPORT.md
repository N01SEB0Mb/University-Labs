Мною були використані бібліотеки _**requests**_ та _**Flask**_ для мови програмування _**Python 3**_

---

## Requests

### Що я використовував з даної бібліотеки:

- Запити (GET, POST і т.д)
- Формування цих запитів (відправлювана інформація, заголовки і т.д)
- Отримання результатів запиту (статус відповіді та надана інформація)
- Обробка куки
- Перевірка SSL-сертифікату

### Які конкретні задачі планували вирішувати за допомогою цієї бібліотеки?

Задача полягає у взаємодії з веб-сайтами постачальників деталей -
необхідно формувати та відправляти запити на сервер
і отримувати відповідь

### Чому було обрано саме цю бібліотеку, а не аналоги?

Для мови Python є великий вибір різноманітних рішень для будь якої задачі.
Конкретно для цієї задачі (відправка HTTP-запитів) існують такі бібліотеки:

 - urllib
 - Requests
 - Octopus
 - HTTPie 
   
Та багато інших.

urllib є стандартною бібліотекою Python 3 тому для завдання вона не підходить.
А з інших я обрав саме Requests, тому що:

 - Бібліотека, напевно, найпопулярніша серед всіх бібліотек для цієї задачі,
   отже має величезну кількість документації, прикладів використання та відповідей на stackoverflow
   
 - Requests має досить простий інтерфейс з яким дуже просто розібратись

 - Бібліотеку реалізовано через ООП

### Наскільки просто та зрозуміло було отримати, встановити, налаштувати та почати використовувати цю бібліотеку?

Бібліотеку було дуже просто встановити як і більшість інших бібліотек для Python 3

Необхідно ввести всього лиш 1 команду в термінал:

`python3 -m pip install requests`

Почати використовувати бібліотеку було дуже просто, важче було розібратись в самому HTTP.
Оскільки бібліотека має зручний інтерфейс, зрозумів роботу протоколу я достатньо швидко

### Наскільки зрозумілою та корисною була документація бібліотеки?

Документацію бібліотеки я би не назвав ідеальною. Розібратись з інтерфейсом дуже просто,
проте є деякі моменти які документація просто не описує. Благо існують багато інших користувачів
які можуть дати відповідь на будь-яке питання по цій бібліотеці

Документацію [реалізовано](https://requests.readthedocs.io/en/master/user/quickstart/#make-a-request)
у вигляді прикладів роботи, а не опису її частин, що є наглядним але не дуже зручним 

### Наскільки було зрозуміло, як саме використовувати бібліотеку, які класи/методи/функції використовувати для вирішення поставлених задач?

Бачивши приклади я дуже швидко зрозумів як користуватись цим і як вирішити мою задачу.
Спочатку я використовував звичайні функції: `requests.get()`, `requests.post()` і т.д
Але з часом я зрозумів що зручніше використовувати об'єкт `requests.Session()`
який сам зберігає всю інформацію (куки, заголовки і т.д).
Пізніше для своїх цілей я успадкував цей клас і додав туди деякі необхідні для себе частини коду

### Наскільки зручно було використовувати бібліотеку, чи не треба було писати багато надлишкового коду?

Бібліотека є достатньо високорівневою, тому кількість коду мінімальна,
що є як плюсом, так і мінусом
Для мене, як для того хто вперше познайомився з HTTP-запитами, це скоріше було позитивною частино, ніж негативною

### Наскільки зрозумілою була поведінка класів/методів/функцій з бібліотеки?

Поведінка класів та функцій є дуже зрозумілою та універсальною.
Знаючи як працювати з одним класом, ти можеш розібратись як працювати і з іншим класом з цієї бібліотеки

### Наскільки зрозумілою була взаємодія між різними класами/методами/функціями цієї бібліотеки, а також взаємодія між бібліотекою та власним кодом?

Взаємодія між класами була достатньо зрозуміла, тому ти завжди знав що ти отримаєш, написавши конкретний код
Я успадкував клас з бібліотеки і додав своїх функцій, що не викликало у мене ніяких труднощів. Все чітко і зрозуміло

### Чи виникали якісь проблеми з використанням бібліотеки? Чи вдалось їх вирішити, як саме?

Проблем які я не зміг вирішити через кілька хвилин у мене майже не виникало.
Єдина проблема яка зараз мене бентежить, це дивна поведінка атрибута timeout об'єкта requests.Session
Для функцій запиту є параметр timeout, який задає обмеження по часу на запит
Атрибут requests.Session.timeout по ідеї має уніфікувати цей параметр для всих функцій, однак він чомусь не працює

Ось як задається timeout для конкретного запиту: 
```python
import requests

session = requests.Session()

request = session.get("https://google.com/", timeout=8)
```

Ось як хотілось би задавати timeout для сесії:
```python
import requests

session = requests.Session()
session.timeout = 8

request = session.get("https://google.com/")
```

Однак, 2-й варіант не працює...

### Що хорошого можна сказати про цю бібліотеку, які були позитивні аспекти використання бібліотеки?

Бібліотека є дуже зручною для користувачів.
І тому якщо ви тільки починаєте пробувати себе в даній області,
то ця бібліотека явно буде моєю рекомендацією для вас

Мені подобається її інтерфейс, який реалізовано як ви захочете:
можете використовувати ООП, можете просто викликати функції запиту,
можете підготовляти запити для відправки і т.п

Також великою перевагою бібліотеки я вважаю її популярність: 
багато людей працює над нею, тому якщо виникне якийсь баг,
його виправлення не заставить вас довго себе чекати. Також
завжди знайдеться той, хто знає відповідь на якесь питання,
яке у вас може виникнути в ході використання бібліотеки

### Що поганого можна сказати про цю бібліотеку, які були негативні аспекти використання бібліотеки?

Особисто я вважаю що документацію бібліотеки зроблено далеко не найкращим чином.
Ти не можеш дізнатись всю інформацію про функцію (які параметри є, що повертає, які помилки може викинути і т.д)
використовуючи дану документацію, що є великим мінусом. Для функцій просто надано кілька прикладів
а далі самі знаходьте якусь інформацію поточніше

### Якби довелось вирішувати аналогічну задачу, але вже враховуючи досвід використання в цій лабораторній роботі, що варто було б робити так само, а що змінити? Можливо, використати інші бібліотеки, чи використати інші можливості цієї бібліотеки, чи інакше організувати код, чи ще щось?

Я однозначно можу рекомендувати цю бібліотеку для використання і сам буду її використовувати,
але все залежить від поставленої задачі. Може бути таке що необхідно буде відправляти дуже велику кількість
запитів з маленьким пінгом, тобто вже буде йти мова про оптимізацію бібліотеки: через те що бібліотека високорівнева,
і далеко не всі її можливості будуть використовуватись, раціональніше буде використовувати щось більш низькорівневе,
наприклад urllib (здається Requests на цій бібліотеці і написана). Однак зазвичай треба небагато запитів, і найбільшу
частину часу просто йде сам запит до сервера, що пришвидшити ніяк не вийде, а час виконання коду на пайтоні мізерний
по зрівнянню з часом запиту. Тому для багатьох задач бібліотека підійде, і завдяки своїй простоті
не потрібно буде прикладати багато зусиль для вирішення конкретної проблеми

В наступних проектах я буду надавати більший пріорітет ООП інтерфейсу, оскільки це зручніше
і надає багато можливостей, які інші методи можуть не надавати

---

## Flask

### Що я використовував з даної бібліотеки:

- Обробка запитів на сервер
- Розбиття на Blueprints
- Декоратор @app.before_request (яка функція буде викликатись перед обробкою запиту)

### Які конкретні задачі планували вирішувати за допомогою цієї бібліотеки?

Задача полягала в тому щоб зробити інтерфейс запитів моєї програми у вигляді HTTP API

### Чому було обрано саме цю бібліотеку, а не аналоги?

В Python 3 напевно є 2 найпопулярніших фреймворка для веб-додатків:
 - Flask
 - Django

Я обрав Flask тому що у мене був мінімальний досвід його використання, а задача не була дуже складною 
(на 'Хакатоні' довелось екстренно написати простий сервер для обробки кількох базових запитів,
і мій товариш по команді запропонував використати дану бібліотеку)

Насправді обрати між цими бібліотеками дуже складно, тому що вони обоє надаються багато 
потрібних можливостей та використовуються величезною кількістю людей (хоча Django, певне, буде попопулярніше)

В майбутньому цікаво спробувати Django та зрівняти досвід використання цих бібліотек між собою та 
все таки вибрати свого фаворита

### Наскільки просто та зрозуміло було отримати, встановити, налаштувати та почати використовувати цю бібліотеку?

Аналогічно з requests, необхідно ввести всього лиш 1 команду в термінал:

`python3 -m pip install Flask`

Але для додаткових можливостей довелось ще встановити Flask-API:

`python3 -m pip install Flask-API`

Знаючи принципи HTTP і використовувавши вже до цього бібліотеку Requests, по суті прийшлось
робити те саме що я роблю з Requests, але з іншого боку, тому труднощів не виникло

### Наскільки зрозумілою та корисною була документація бібліотеки?

[Документація](https://flask.palletsprojects.com/) Flask, так само як і Requests, оформлена у вигляді прикладів.
Як і Requests, бібліотека є дуже популярною тому окрім стандартної документації є багато сторонніх ресурсів
на яких навчають використовувати цю бібліотеку, тому почати було доволі легко 

### Наскільки було зрозуміло, як саме використовувати бібліотеку, які класи/методи/функції використовувати для вирішення поставлених задач?

Я одразу зрозумів як використовувати бібліотеку, тим більше для моєї задачі
не потрібно було багато знань, і я обійшовся базовими функціями

### Наскільки зручно було використовувати бібліотеку, чи не треба було писати багато надлишкового коду?

Бібліотеку було дуже зручно використовувати, і для задачі багато коду писати не прийшлось

Наскільки я знаю, Flask по зрівнянню з Django є більш кастомізабельною бібліотекою в якій деякі
можливості конкурента прийдеться писати самому. Однак є багато готових рішень для цієї бібліотеки,
тому набагато більше коду ніж на Django писати не прийдеться

Особисто мені подобається те що бібліотека є більш кастомізабельна, однак
при вирішенні своєї задачі я не стикався з цим тому не можу нічого точно сказати.
Напевно все таки при написані якогось масштабнішого продукту зручніше буде використовувати можливості Django

### Наскільки зрозумілою була поведінка класів/методів/функцій з бібліотеки?

Поведінка була зрозумілою, тому труднощів не виникло

### Чи виникали якісь проблеми з використанням бібліотеки? Чи вдалось їх вирішити, як саме?

Оскільки задача дуже проста і коду не є багато, то багато проблем просто не могло виникнути

Єдина проблема з чим я зіткнувся, це дивна поведінка при використанні на локальному сервері:
Якщо задати хост - localhost, то між запитом від клієнта то прибуття запиту на сервер проходить доволі великий час
(не пам'ятаю точно скільки, але в районі кількох секунд)

Оскільки програма використовується на локальному сервері, то проблема була критичною.
Пошукавши вирішення, я знайшов інформацію про те що
[це не у мене одного виникло](https://stackoverflow.com/questions/11150343/slow-requests-on-local-flask-server).
Із рішень я вибрав найпростіше: якщо замінити localhost на хост який задається цифрами (наприклад 127.0.0.1)
то проблема вирішується і запити приходять моментально

### Що хорошого можна сказати про цю бібліотеку, які були позитивні аспекти використання бібліотеки?

Бібліотека не є складною і розібратись з нею доволі легко. Для простих задач я однозначно буду її використовувати знову

### Що поганого можна сказати про цю бібліотеку, які були негативні аспекти використання бібліотеки?

Для моєї задачі не потрібно було багато засобів, тому мені в головою було достатньо того що є і з цим проблем не виникло

Однак якщо вам потрібно щось інше додати, то прийдеться самому це робити, на відміну від Django
Наприклад, наскільки я знаю, в Django є підтримка баз даних та робота з ними доволі проста там
А Flask немає ніяких інструментів для цього, тому якщо така задача виникне, прийдеться паритись і шукати якесь рішення
Думаю, таких прикладів можна не один десяток перечислити

### Якби довелось вирішувати аналогічну задачу, але вже враховуючи досвід використання в цій лабораторній роботі, що варто було б робити так само, а що змінити? Можливо, використати інші бібліотеки, чи використати інші можливості цієї бібліотеки, чи інакше організувати код, чи ще щось?

Для аналогічної задачі я би з радістю знову використаю Flask, проте хотілось би і Django спробувати та порівняти їх.
Враховуючи те що Django більше компаній використовує, напевно мій пріорітет буде ближче до Django, тому що
і роботу на ньому буде знайти легше, і робити масштабні задачі також буде легше.

Хоча в цій сфері все одно є такі задачі, під які краще буде вибрати якісь аналоги на інших мовах.
Якщо на сервер іде серйозне навантаження, компільовані мови будуть швидше справлятись
зі своєю задачею, і, відповідно, веб-сайт буде працювати швидше

